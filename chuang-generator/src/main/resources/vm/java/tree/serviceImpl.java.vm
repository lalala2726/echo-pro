package ${packageName}.service.impl;

import ${packageName}.mapper.${ClassName}Mapper;
import ${packageName}.model.entity.${ClassName};
import ${packageName}.model.request.${businessName}.${ClassName}AddRequest;
import ${packageName}.model.request.${businessName}.${ClassName}QueryRequest;
import ${packageName}.model.request.${businessName}.${ClassName}UpdateRequest;
import ${packageName}.service.${ClassName}Service;
import cn.hutool.core.util.StrUtil;
import cn.zhangchuangla.common.core.enums.ResponseCode; // 新增：导入ResponseCode
import cn.zhangchuangla.common.core.exception.ServiceException; // 新增：导入ServiceException
import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.BeanUtils;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional; // 新增：导入事务注解

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * ${functionName} 服务实现类
 *
 * @author ${author}
 * @date ${datetime}
 */
@Service
@RequiredArgsConstructor
public class ${ClassName}ServiceImpl extends ServiceImpl<${ClassName}Mapper, ${ClassName}>
        implements ${ClassName}Service {

    private final ${ClassName}Mapper ${classNameLower}Mapper;

    /**
     * ${functionName}树形列表
     *
     * @param request 查询参数
     * @return 树形列表
     */
    @Override
    public List<${ClassName}> select${ClassName}Tree(${ClassName}QueryRequest request) {
        LambdaQueryWrapper<${ClassName}> queryWrapper = new LambdaQueryWrapper<>();
        
        // 根据查询条件构建查询
        if (StrUtil.isNotBlank(request.get${TreeName}())) {
            queryWrapper.like(${ClassName}::get${TreeName}, request.get${TreeName}());
        }
        
        List<${ClassName}> list = ${classNameLower}Mapper.selectList(queryWrapper);
        // 初始调用 buildTree 时, 父ID传入 null, 表示获取所有根节点 (其父ID为null的节点)
        return buildTree(list, null); 
    }

    /**
     * 添加${functionName}
     *
     * @param request 请求参数
     * @return 操作结果
     */
    @Override
    public boolean add${ClassName}(${ClassName}AddRequest request) {
        ${ClassName} ${classNameLower} = new ${ClassName}();
        BeanUtils.copyProperties(request, ${classNameLower});
        return save(${classNameLower});
    }

    /**
     * 根据ID删除${functionName}
     *
     * @param id ${functionName}ID
     * @return 操作结果
     */
    /**
     * 根据ID删除${functionName}
     * (如果配置了级联删除,则会一并删除所有子孙节点)
     *
     * @param id ${functionName}ID
     * @return 操作结果
     */
    @Override
    @Transactional(rollbackFor = Exception.class) // 新增/确保：事务注解
    public boolean delete${ClassName}ById(Long id) {
        // 从代码生成配置中获取当前树表的 cascadeDeleteTree 设置 (假设 'table' 是 GenTable 实例)
        // GenTable 对象 'table' 应由 VelocityUtils.prepareContext 放入上下文中
        String cascadeDelete = "${table.cascadeDeleteTree}"; // '1' 表示 true (启用级联删除)

        if ("1".equals(cascadeDelete)) {
            // (级联删除已启用)
            // 递归删除所有子孙节点
            // 注意: deleteAllChildrenRecursive 需要 ${classNameLower}Mapper 作为参数
            deleteAllChildrenRecursive(id, ${classNameLower}Mapper); 
            // 删除父节点自身
            return removeById(id); 
        } else {
            // (级联删除未启用或配置非'1')
            // 检查是否有直接子节点 (原有逻辑，但使用 mapper.selectCount)
            LambdaQueryWrapper<${ClassName}> queryWrapper = new LambdaQueryWrapper<>();
            queryWrapper.eq(${ClassName}::get${TreeParentCode}, id);
            // 使用 ${classNameLower}Mapper 进行查询，更明确
            long count = ${classNameLower}Mapper.selectCount(queryWrapper); 
            
            if (count > 0) {
                // 如果存在子节点且未启用级联删除，则抛出异常
                throw new RuntimeException("存在子节点，且未启用级联删除，不允许删除 (子节点数量: " + count + ")");
            }
            // 如果没有子节点，则直接删除当前节点
            return removeById(id);
        }
    }

    /**
     * 根据ID查询${functionName}信息
     *
     * @param id ID
     * @return ${functionName}信息
     */
    @Override
    public ${ClassName} get${ClassName}ById(Long id) {
        return getById(id);
    }

    /**
     * 修改${functionName}信息
     *
     * @param request 请求参数
     * @return 操作结果
     */
    @Override
    public boolean update${ClassName}(${ClassName}UpdateRequest request) {
        ${ClassName} ${classNameLower} = new ${ClassName}();
        BeanUtils.copyProperties(request, ${classNameLower});

        // --- BEGIN: 新增父节点自引用检查 ---
        // 获取当前节点的ID (例如: getId())
        // (Velocity: ${primaryKey.javaFieldCapitalize} 应该生成类似 getId, getMenuId 的方法名)
        Object nodeId = ${classNameLower}.get${primaryKey.javaFieldCapitalize}();
        // 获取当前节点设置的父ID (例如: getParentId())
        // (Velocity: ${TreeParentCode} 应该生成类似 getParentId, getParentMenuId 的方法名)
        Object parentId = ${classNameLower}.get${TreeParentCode}();

        // 检查父ID是否与节点自身的ID相同 (且ID不为null, 主要针对更新操作)
        // (Chinese: Check if the parent ID is the same as the node's own ID (and ID is not null, mainly for update operations))
        if (nodeId != null && nodeId.equals(parentId)) {
            // 可以使用项目中已有的 ResponseCode 或直接抛出 IllegalArgumentException
            // (Chinese: You can use an existing ResponseCode from the project or throw IllegalArgumentException directly)
            throw new ServiceException(ResponseCode.PARAM_ERROR, "父节点不能是节点本身 (Parent node cannot be the node itself)");
        }
        // --- END: 新增父节点自引用检查 ---

        return updateById(${classNameLower});
    }

    /**
     * 构建树形结构 (递归方法)
     * (此方法将扁平列表数据转换为树形结构)
     *
     * @param list 原始数据列表 (包含所有节点)
     * @param parentIdValue 当前层级的父节点ID (对于根节点, 此值为 null)
     * @return 构建好的树形结构列表 (当前层级的子节点)
     */
    @Override
    public List<${ClassName}> buildTree(List<${ClassName}> list, Object parentIdValue) { // 修改: parentId -> parentIdValue, 类型 String -> Object
        List<${ClassName}> tree = new ArrayList<>();
        
        for (${ClassName} item : list) {
            // 使用 Objects.equals 进行 null 安全的父ID比较
            // 假设 item.get${TreeParentCode}() 返回的是实际类型的父ID (可能为 null, 例如 Long, Integer, String)
            if (java.util.Objects.equals(parentIdValue, item.get${TreeParentCode}())) { // 修改: 使用 Objects.equals 比较, 不再需要 String.valueOf
                // 递归查找子节点, 使用当前节点的ID (item.get${TreeCode}()) 作为子节点的父ID
                // item.get${TreeCode}() 返回的是实际类型, 直接传递
                List<${ClassName}> children = buildTree(list, item.get${TreeCode}()); 
                item.setChildren(children);
                tree.add(item);
            }
        }
        
        return tree;
    }

    /**
     * 递归删除所有子孙节点 (私有辅助方法)
     * (Recursively deletes all descendant nodes)
     *
     * @param parentIdValue 当前父节点的ID值 (whose children are to be deleted)
     * @param currentMapper 用于数据库操作的Mapper实例
     */
    private void deleteAllChildrenRecursive(Object parentIdValue, ${ClassName}Mapper currentMapper) {
        // 1. 查找当前父节点的所有直接子节点
        // (Find all direct children of the current parent node)
        LambdaQueryWrapper<${ClassName}> childrenWrapper = new LambdaQueryWrapper<>();
        // 使用 get${TreeParentCode} 方法引用来查询父ID匹配的子节点
        childrenWrapper.eq(${ClassName}::get${TreeParentCode}, parentIdValue);
        List<${ClassName}> children = currentMapper.selectList(childrenWrapper);

        // 如果没有子节点, 则递归终止
        // (If there are no children, terminate recursion for this branch)
        if (children == null || children.isEmpty()) {
            return; 
        }

        for (${ClassName} child : children) {
            // 2. 递归删除当前子节点的所有后代
            // (Recursively delete all descendants of the current child node)
            // 使用 get${TreeCode} 方法引用来获取当前子节点的ID，作为下一次递归的父ID
            deleteAllChildrenRecursive(child.get${TreeCode}(), currentMapper);

            // 3. 删除当前子节点本身
            // (Delete the current child node itself)
            // 同样使用 get${TreeCode} 获取ID进行删除
            currentMapper.deleteById(child.get${TreeCode}());
        }
    }
}